//
//  main.cpp
//  chapter16
//
//  Created by vividhsu on 7/30/15.
//  Copyright (c) 2015 Vividhsu. All rights reserved.
//

#include <iostream>
#include <vector>
#include <list>
#include <fstream>
#include <utility>

#include "Sales_data.h"
#include "Blob.h"
#include "Screen.h"
#include "Vec.h"
#include "TextQuery.h"
#include "QueryResult.h"
#include "debug_rep.h"


using std::cout;
using std::endl;
using std::vector;
using std::list;
using std::ifstream;

void ex16_01() {
    cout << "-----ex16.1-----" << endl;
    cout << "instantiation: class or function generated by the compiler from a template." << endl;
}

template <typename T>
int compare(const T& v1, const T& v2) {
    if (v1 < v2)
        return -1;
    if (v2 < v1)
        return 1;
    return 0;
}

void ex16_02() {
    cout << "-----ex16.2-----" << endl;
    cout << compare(3, 4) << endl;
    vector<int> v1{1, 2, 3};
    vector<int> v2{2, 3, 4};
    cout << compare(v1, v2);
}

void ex16_03() {
    cout << "-----ex16.3-----" << endl;
    Sales_data data1;
    Sales_data data2;
    //cout << compare(data1, data2);
    cout << "Invalid operands to binary expression (const Sales_data and const Sales_data) in line if (v1 < v2)" << endl;
}

template <typename Iterator, typename T>
Iterator myFind(Iterator first, Iterator last, const T& target) {
    while (first != last) {
        if (*first == target) {
            return first;
        }
        ++first;
    }
    return last;
}

void ex16_04() {
    cout << "-----ex16.4-----" << endl;
    vector<int> a{1, 2, 3, 4};
    auto it = myFind(a.begin(), a.end(), 3);
    cout << (it == a.end()) << endl;
    list<string> b{"a", "b", "c", "d"};
    auto it2 = myFind(b.begin(), b.end(), "e");
    cout << (it2 == b.end()) << endl;
}

template <typename T, unsigned N>
void myPrint(const T (&arr)[N]) {
    for (size_t i = 0; i != N; ++i) {
        cout << arr[i] << endl;
    }
}

void ex16_05() {
    cout << "-----ex16.5-----" << endl;
    string s[] = {"aa", "bb", "cc"};
    char c[] = {'a', 'b', 'c', 'd'};
    int  i[] = {1, 2, 3};
    myPrint(s);
    myPrint(c);
    myPrint(i);
}

template <typename T, size_t N>
T* myBegin(T (&arr)[N]) {
    T* iter = &arr[0];
    return iter;
}

template <typename T, size_t N>
T* myEnd(T (&arr)[N]) {
    T* iter = &arr[N - 1];
    iter++;
    return iter;
}


void ex16_06() {
    cout << "-----ex16.6-----" << endl;
    string s[] = {"aa", "bb", "cc" };
    char c[] = {'a', 'b', 'c', 'd'};
    int  i[] = {1, 2, 3};
    cout << *myBegin(s) << *(myEnd(s) - 1) << endl;
    cout << *myBegin(c) << *(myEnd(c) - 1) << endl;
    cout << *myBegin(i) << *(myEnd(i) - 1) << endl;
}

template <typename T, size_t N>
constexpr size_t mySize(const T (&arr)[N]) {
    return N;
}

void ex16_07() {
    cout << "-----ex16.7-----" << endl;
    string s[] = {"aa", "bb", "cc" };
    char c[] = {'a', 'b', 'c', 'd'};
    int  i[] = {1, 2, 3};
    cout << mySize(s) << endl;
    cout << mySize(c) << endl;
    cout << mySize(i) << endl;
}

void ex16_08() {
    cout << "-----ex16.8-----" << endl;
    cout << "all the container defines !=, easy to implement the template" << endl;
}

void ex16_09() {
    cout << "-----ex16.9-----" << endl;
    cout << "function template is a blueprint for generating functions. definition from which specific functions can be instantiated; \n";
    cout << "class template is a blueprint for generating classes. definition from which specific class can be instantiated" << endl;
}

void ex16_10() {
    cout << "-----ex16.10-----" << endl;
    cout << "when the compiler instantiates a class from template, it rewrites the class template, replacing each instance of the template parameter by the given template argument." << endl;
}

template <typename elemType> class ListItem;
template <typename elemType> class List {
public:
    List<elemType>();
    List<elemType>(const List<elemType>&);
    list<elemType>& operator=(const List<elemType>&);
    ~List();
    
    void insert(ListItem<elemType> *ptr, elemType value);

private:
    ListItem<elemType> *front, *end;
};

void ex16_11() {
    cout << "-----ex16.11-----" << endl;
    
}

void ex16_12() {
    cout << "-----ex16.12-----" << endl;
    Blob<int> a;
    a.push_back(1);
    a.push_back(2);
    cout << a.at(0) << endl;
    BlobPtr<int> ap(a);
    ap++;
    cout << *ap << endl;    
}

void ex16_13() {
    cout << "-----ex16.13-----" << endl;
    initializer_list<int> temp = {1, 2};
    Blob<int> a(temp);
    BlobPtr<int> ap(a);
    Blob<int> b(temp);
    BlobPtr<int> bp(a);
    cout << (ap == bp) << endl;
}

void ex16_14() {
    cout << "-----ex16.14-----" << endl;
    
}

void ex16_15() {
    cout << "-----ex16.15-----" << endl;
    Screen<5,5> scr('c');
    Screen<5,5> scr2;
    
    // output src to the screen
    std::cout<<scr;
    // input connet  to the  src
    std::cin>>scr2;
    // test input
    std::cout<<scr2;
}

void ex16_16() {
    cout << "-----ex16.16-----" << endl;
    Vec<int> vi;
    vi.push_back(1);
}

void ex16_17() {
    cout << "-----ex16.17-----" << endl;
    cout << "when we want to inform the compiler that a name represents a type, we must use the keyword typename, not class." << endl;
}


void ex16_18() {
    cout << "-----ex16.18-----" << endl;
    /**
    (1) template <typename T, U, typename V> void f1(T, U, V);
    illegal. template <typename T, typename U, typename V> void f1(T, U, V);
    
    (2) template <typename T> T f2(int &T);
    illegal. template <typename T> T f2(T&);
     
    (3) inline template <typename T> T foo(T, unsigned int*);
    illegal. template <typename T> inline T foo(T, unsigned int*);
     
    (4) template <typename T> f4(T, T);
    illegal. template <typename T> T f4(T, T);
     
    (5) typedef char Ctype;
        template <typename Ctype> Ctype f5(Ctype a);
     illegal. typedef char C;
               template <typename Ctype> Ctype f5(Ctype a);
     
     */
}

template <typename T>
void print19(T& container) {
    for (typename T::size_type i = 0; i != container.size(); i++) {
        cout << container[i] << " ";
    }
    cout << endl;
}

void ex16_19() {
    cout << "-----ex16.19-----" << endl;
    vector<int> a = {1,2,3,4};
    print19(a);
}

template <typename T>
void print20(T& container) {
    for (auto it = container.begin(); it != container.end(); it++) {
        cout << *it << " ";
    }
    cout << endl;
}

void ex16_20() {
    cout << "-----ex16.20-----" << endl;
    vector<int> a = {1,2,3,4};
    print20(a);
}

void ex16_21() {
    cout << "-----ex16.21-----" << endl;
    
}

void ex16_22(const char* input) {
    cout << "-----ex16.22-----" << endl;
    ifstream file(input);
    TextQuery a(file);
    QueryResult res = a.query("article");
    print(cout, res);
    cout << "end of 16.22" << endl;
}

void ex16_23() {
    cout << "-----ex16.23-----" << endl;
}

void ex16_24() {
    cout << "-----ex16.24-----" << endl;
    vector<short> vs = {1,2,3};
    Blob<int> vi(vs.begin(), vs.end());
}

void ex16_25() {
    cout << "-----ex16.25-----" << endl;
    /**
    // instantiation declaration. compiler won't generate code for that instaintiation in that file.
    extern template class vector<string>;
    // instantiation definition. compiler instantiates all members.
    template class vector<Sales_data>;
    */
}

void ex16_32() {
    cout << "-----ex16.32-----" << endl;
    cout << "During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generates a version of the function that best matches the given call." << endl;
}

void ex16_33() {
    cout << "-----ex16.33-----" << endl;
    cout << "const conversion and array or function to pointer are the only automatic conversions for arguments to parameters with template types." << endl;
}

void ex16_34() {
    cout << "-----ex16.34-----" << endl;
    // compare("hi", "world");   illegal, size not match
    compare("bye", "dad");       //char (&arr)[3]
}



void ex16_35() {
    cout << "-----ex16.35-----" << endl;
    /**
    template <typename T> T calc(T, int);
    template <typename T> T fcn(T, T);
    double d;
    float f;
    char c;
    calc(c, 'c');  // T is char, convert 'c' to int
    calc(d, f);   // T is double, convert f to int
    fcn(c, 'c');  // T is char
    //fcn(d, f);  illegal, d and f are different types
    */
}


void ex16_36() {
    cout << "-----ex16.36-----" << endl;
    /**
    template <typename T> void f1(T, T);
    template <typename T1, typename T2> void f2(T1, T2);
    int i = 0, j = 42, *p1 = &i, *p2 = &j;
    const int *cp1 = &i, *cp2 = &j;
    f1(p1, p2);   // T is int*
    f2(p1, p2);   // T1 and T2 are int*
    f1(cp1, cp2); // T is int*,  const is ignored
    f2(cp1, cp2); // T1 and T2 are int*, const is ignored
    // f1(p1, cp1);  illegal
    f2(p1, cp1);  // T1 is int*, T2 is int*
    */
}


void ex16_37() {
    cout << "-----ex16.37-----" << endl;
    int i = 90;
    double d = 87;
    max<int>(i, d);
}

void ex16_38() {
    cout << "-----ex16.38-----" << endl;
    cout << "template <class T, class... Args> shared_ptr<T> make_shared (Args&&... args);\n";
    cout << "T is used in the return type, compiler can't deduce it, we have to explicit sepcify. " << endl;
}

void ex16_39() {
    cout << "-----ex16.39-----" << endl;
    compare<string>("hello", "hi");
}

template <typename T>
auto sum(T a, T b) -> decltype(a + b)
{
    return a + b;
}

void ex16_41() {
    cout << "-----ex16.41-----" << endl;
    cout << sum(1122334455667788, 22334455667788) << endl;
}

void ex16_42() {
    cout << "-----ex16.42-----" << endl;
    /**
    template <typename T> void g(T&& val);
    int i = 0;
    const int ci = i;
    g(i);   // T is int&, val is int&& & => int&
    g(ci);  // T is const int&, val is const int&& & => const int&
    g(i * ci); // T is int, val is int&&
    */
}

void ex16_43() {
    cout << "-----ex16.43-----" << endl;
    /**
     g(i = ci) // T is int&, val is int&& & => int&
    */
}

void ex16_44() {
    cout << "-----ex16.44-----" << endl;
    /**
     template <typename T> void g(T val);
     int i = 0;
     const int ci = i;
     g(i);   // T is int, val is int
     g(ci);  // T is int, val is int
     g(i * ci); // T is int, val is int
     
     
     template <typename T> void g(const T& val);
     int i = 0;
     const int ci = i;
     g(i);   // T is int, val is const int&
     g(ci);  // T is int, val is const int&
     g(i * ci); // T is int
    */
}

void ex16_45() {
    cout << "-----ex16.45-----" << endl;
    /**
     template <typename T> void g(T&& val) {
        vector<T> v;
     }
     
     T is int
    */
}


void ex16_46() {
    cout << "-----ex16.46-----" << endl;
    /**
     for (size_t i = 0; i != size(); ++i)
        alloc.construct(dest++, std::move(*elem++));
     
     std::move convert the lvalue to rvalue
     */
}

void f1(int v1, int v2) {
    cout << v1 << " " << ++v2 << endl;
}

void f2(int v1, int &v2) {
    cout << v1 << " " << ++v2 << endl;
}

void f3(int &&v1, int v2) {
    cout << v1 << " " << ++v2 << endl;
}

template <typename F, typename T1, typename T2>
void flip(F f, T1&& t1, T2&& t2) {
    f(std::forward<T2>(t2), std::forward<T1>(t1));
}

void ex16_47() {
    cout << "-----ex16.47-----" << endl;
    int i = 15;
    flip(f1, i, 51);
    flip(f2, i, 51);
    flip(f2, i, 51);
}

void ex16_48() {
    cout << "-----ex16.48-----" << endl;
    string s("hi");
    cout << debug_rep(s) << endl;
    const string *sp = &s;
    //cout << debug_rep(sp) << endl;
    //cout << debug_rep("hi world") << endl;
}

template <typename T> void f(T)
{
    cout << "f(T) called" << endl;
}

template <typename T> void f(const T*)
{
    cout << "f(const T*) called" << endl;
}

template <typename T> void g(T) {
    cout << "g(T) called" << endl;
}

template <typename T> void g(T*) {
    cout << "g(T*) called" << endl;
}

void ex16_49() {
    cout << "-----ex16.49-----" << endl;
    int i = 42, *p = &i;
    const int ci = 0, *p2 = &ci;
    g(42);    // g(T), T is int
    g(p);     // g(T*), T is int
    g(ci);    // g(T), T is const int
    g(p2);    // g(T*), T is const int
    f(42);    // f(T), T is int
    f(p);     // f(T), T is int*
    f(ci);    // f(T), T is const int
    f(p2);    // f(T*), T is int
}



void ex16_50() {
    cout << "-----ex16.50-----" << endl;
    int i = 42, *p = &i;
    const int ci = 0, *p2 = &ci;
    g(42);
    g(p);
    g(ci);
    g(p2);
    f(42);
    f(p);
    f(ci);
    f(p2);
}

template <typename T, typename... Args>
void foo(const T& t, const Args& ... rest){
    cout << sizeof...(Args) << endl;
    cout << sizeof...(rest) << endl;
}

void ex16_51() {
    cout << "-----ex16.51-----" << endl;
    
}

void ex16_52() {
    cout << "-----ex16.52-----" << endl;
    int i = 0;
    double d = 3.14;
    string s = "how now brown cow";
    foo(i, s, 42, d);
    foo(s, 42, "hi");
    foo(d, s);
    foo("hi");
}

template <typename T>
ostream &print(ostream &os, const T& t) {
    return os << t;
}

template <typename T, typename... Arg>
ostream &print(ostream &os, const T& t, const Arg& ... arg) {
    os << t << ", ";
    return print(os, arg...);
}

void ex16_53() {
    cout << "-----ex16.53-----" << endl;
    int i = 0;
    double d = 3.14;
    string s = "how now brown cow";
    print(cout, i, s, d);
}

void ex16_54() {
    cout << "-----ex16.54-----" << endl;
    cout << "it won't compile." << endl;
}

void ex16_55() {
    cout << "-----ex16.55-----" << endl;
    cout << "no matching function for call to print(os)" << endl;
}

template <typename... Args>
ostream &errorMsg(ostream &os, const Args&... rest) {
    return print(os, debug_rep(rest)...);
}

void ex16_56() {
    cout << "-----ex16.56-----" << endl;
    
}

void ex16_57() {
    cout << "-----ex16.57-----" << endl;
    cout << "the one takes initializer_list only support one type" << endl;
}


int main(int argc, const char * argv[]) {
//    ex16_01();
//    ex16_02();
//    ex16_03();
//    ex16_04();
//    ex16_05();
//    ex16_06();
//    ex16_07();
//    ex16_08();
//    ex16_09();
//    ex16_10();
//    ex16_11();
//    ex16_12();
//    ex16_13();
//    ex16_14();
//    ex16_15();
//    ex16_16();
//    ex16_17();
//    ex16_18();
//    ex16_19();
//    ex16_20();
//    ex16_21();
//    ex16_22(argv[1]);
//    ex16_23();
//    ex16_24();
//    ex16_25();
//    ex16_32();
//    ex16_33();
//    ex16_34();
//    ex16_35();
//    ex16_36();
//    ex16_37();
//    ex16_38();
//    ex16_39();
//    ex16_41();
//    ex16_42();
//    ex16_43();
//    ex16_44();
//    ex16_45();
//    ex16_46();
//    ex16_47();
//    ex16_48();
//    ex16_49();
//    ex16_50();
//    ex16_51();
//    ex16_52();
//    ex16_53();
//    ex16_54();
//    ex16_55();
//    ex16_56();
//    ex16_57();
    return 0;
}
